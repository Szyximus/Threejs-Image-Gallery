<html>
	<head>
		<title>three.js WebGL Roulette Gallery</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/LightProbeGenerator.js"></script>
		<script src="js/gsap.min.js"></script>
		<script src="js/EasePack.min.js"></script>
		<script src="js/EaselPlugin.min.js"></script>
		<script src="js/threex.domevents.js"></script>
		<!--<script src="js/Draggable.js"></script>-->

		<script>
			

			var scene, camera, renderer, env, cylinder, lightProbe, photos, domEvents, selected, radius, holdCylinder, mouseX;
			var zoom = false;
			var gallery = [];
			

			
			Init();
			LoadPhotoList();
			
			//TEMPORARY CAMERA CONTROLS:
			//let controls = new THREE.OrbitControls(camera, renderer.domElement);
			//controls.addEventListener('change', renderer);

			//CylinderControls:
			document.addEventListener('mousemove', function(event){
					var newMouseX	= (event.clientX / window.innerWidth ) - 0.5;

					var deltaMouseX = newMouseX - mouseX;

					if (holdCylinder) {

						cylinder.rotation.y += deltaMouseX * Math.PI/2;
						//NormalizeRotation();

					}

					mouseX = newMouseX;
					NormalizeRotation();

				}, false)
			
			render();

			function Init(){
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.01, 100 );

				renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement);

				domEvents = new THREEx.DomEvents(camera,renderer.domElement);

				window.addEventListener('resize', () => { //Handle Window Resize
					renderer.setSize( window.innerWidth, window.innerHeight);
					camera.aspect = window.innerWidth / window.innerHeight;
					Unzoom();
				})

				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );
				// light

				directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				directionalLight.position.set( 3, 4, 5 );
				scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xffffff, 2, 100, 20 );
				pointLight.position.set(0,2,0);
				camera.add(pointLight);
				scene.add(camera);
				//scene.add(pointLight);
								
				// envmap
				var genCubeUrls = function ( prefix, postfix ) {
		 		return [
		 			prefix + 'px' + postfix, prefix + 'nx' + postfix,
		 			prefix + 'py' + postfix, prefix + 'ny' + postfix,
					prefix + 'pz' + postfix, prefix + 'nz' + postfix
		 			];
			 	};
			 	var urls = genCubeUrls( 'textures/cube/pisa/', '.png' );
			 	new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {
					cubeTexture.encoding = THREE.sRGBEncoding;
			 		lightProbe.copy( THREE.LightProbeGenerator.fromCubeTexture( cubeTexture ) );
					env = cubeTexture;

				 } );
				 
			 	var geometry = new THREE.CylinderGeometry(1,1,64,64);
				var material = new THREE.MeshStandardMaterial( {
			 			color: 0xffffff,
			 			metalness: 0,
			 			roughness: 0.5,
			 			envMap: env,
			 			envMapIntensity: THREE.envMapIntensity * 100,
			 		} );
				cylinder = new THREE.Mesh( geometry, material );
				cylinder.castShadow = true;
				cylinder.receiveShadow = true;
				scene.add( cylinder);

				domEvents.addEventListener(cylinder, 'mousedown', event => GrabCylinder(cylinder));
				domEvents.addEventListener(cylinder, 'mouseup', event => LetGoOfCylinder(cylinder));
				domEvents.addEventListener(cylinder, 'mouseover', event => {
					console.log(cylinder.rotation.y);
				});
				document.addEventListener('mouseup', event => LetGoOfCylinder(cylinder));

				//domEvents.addEventListener(cylinder, 'touchstart', event => GrabCylinder(cylinder));
				//domEvents.addEventListener(cylinder, 'touchend', event => LetGoOfCylinder(cylinder));
				//domEvents.addEventListener(cylinder, 'touchcancel', event => LetGoOfCylinder(cylinder));

			}

			function render() {
				requestAnimationFrame( render );

				//console.log(photos);

				renderer.render( scene, camera );
			};

			function LoadPhotoList(){

				var xmlhttp = new XMLHttpRequest();
				xmlhttp.onreadystatechange = function() {
 					if (this.readyState == 4 && this.status == 200) {
    				var myObj = JSON.parse(this.responseText);
    				photos = myObj;
  					}
				};
				xmlhttp.open("GET", "./photos.json", true);
				xmlhttp.send();

				var waitForLoad = timeoutms => new Promise((r, j)=>{
    				var check = () => {
					  console.warn('checking')
      				if(typeof photos !== 'undefined'){
						r();
						console.log(photos);
						PrepareGallery();
					  } 
      				else if((timeoutms -= 100) < 0)
        				j('timed out!')
      				else
        				setTimeout(check, 100)
    				}
   			 		setTimeout(check, 100)
  				})
		 	  	waitForLoad(2000);
			}
			function PrepareGallery(){

				for (var i = 0; i < photos.length; i++){
					var geometry = new THREE.PlaneGeometry(2.5,3.5);
					var texture = new THREE.TextureLoader().load('photos/'+ photos[i])
					texture.magFilter = THREE.NearestFilter;
					texture.minFilter = THREE.LinearMipmapNearestFilter;
					texture.anisotropy = 16;
					var material = new THREE.MeshPhysicalMaterial( {
						color: 0xffffff,
						map: texture
			 		} );
					var card = new THREE.Mesh( geometry, material );
					scene.add(card);
					gallery.push(card);
				}

				radius = (3 * gallery.length) / (2 * Math.PI);

				//cylinder.scale.x = cylinder.scale.x * radius;

				Unzoom();

				for (var i = 0; i < gallery.length; i++){
					if (i == 0) var angle = 0;
					else var angle = (i / (gallery.length)) * Math.PI * 2;
    				gallery[i].position.x = (radius * Math.sin(angle));
					gallery[i].position.z = (radius * Math.cos(angle));
					gallery[i].rotation.y = angle;
					gallery[i].name = (JSON.stringify(angle));
					gallery[i].parent = cylinder;
				}
				for (let card of gallery){
					//console.log(card);
					domEvents.addEventListener(card, 'mouseover', event => HighlightCard(card));
					domEvents.addEventListener(card, 'mouseout', event => UnhighlightCard(card));
					domEvents.addEventListener(card, 'mousedown', event => GrabCard(card));
					domEvents.addEventListener(card, 'mouseup', event => LetGoOfCard(card));

					domEvents.addEventListener(card, 'click', event => ZoomSwap(card));

					domEvents.addEventListener(card, 'touchstart', event => GrabCard(card));
					domEvents.addEventListener(card, 'touchend', event => LetGoOfCard(card));
					//domEvents.addEventListener(card, 'touchcancel', event => LetGoOfCard(card));

				}

			}
			function HighlightCard(card){
				console.log(card.rotation.y);
				gsap.to(card.position, .5, {x: (radius + 0.1) * Math.sin(card.name), z: (radius + 0.1) * Math.cos(card.name), y : 0, ease: Expo.easeOut});

			}

			function UnhighlightCard(card){
				//console.log(card);
				gsap.to(card.position, .5, {x: radius * Math.sin(card.name), z: radius * Math.cos(card.name), y: 0, ease: Expo.easeOut});
			}

			function GrabCard(card){
				//console.log(card);
				gsap.to(card.position, .5, {y : 0.5, ease: Expo.easeOut});
			}

			function LetGoOfCard(card){
				//console.log(card);
				gsap.to(card.position, .5, {y : 0, ease: Expo.easeOut});
			}

			function GrabCylinder(cylinder){
				//console.log(cylinder);
				//gsap.to(cylinder.rotation, 2, {y : cylinder.rotation.y + 1, ease: Expo.easeOut});
				holdCylinder = true;
				//cylinder.rotation.y = THREE.Math.lerp(cylinder.rotation.y, mousex, 0.5);
				
			}

			function LetGoOfCylinder(cylinder){
				//console.log(cylinder);
				//gsap.to(cylinder.rotation, 2, {y : cylinder.rotation.y + 1, ease: Expo.easeOut});
				NormalizeRotation();
				holdCylinder = false;
				var angle = (1 / (gallery.length/2)) * Math.PI;
				var cylinderDestination = Math.round(cylinder.rotation.y / angle) * angle;
				gsap.to(cylinder.rotation, 0.5, {y : cylinderDestination, ease: Expo.easeOut, onComplete: NormalizeRotation()});
				console.log(cylinderDestination);
			}

			function ZoomSwap(card){
				//console.log(Math.PI - Math.abs( Math.abs(cylinder.rotation.y - (card.name *1.0)) - Math.PI));
				if (zoom){
					Unzoom();
					//gsap.to(cylinder.rotation, 0.5, {y : card.name * -1, ease: Expo.easeOut});
				}
				else{
					if (Math.abs(Math.PI - Math.abs( Math.abs(-cylinder.rotation.y - (card.name *1.0)) - Math.PI)) < 0.01) Zoom()
					else if (Math.abs(Math.PI - Math.abs( Math.abs(-cylinder.rotation.y - (card.name *1.0)) - Math.PI)) <= Math.abs(Math.PI - Math.abs( Math.abs(-cylinder.rotation.y - (card.name *1.0) - Math.PI*2) - Math.PI))){
						NormalizeRotation();
						gsap.to(cylinder.rotation, 0.5, {y :  -1 * card.name + Math.PI * 2, ease: Expo.easeOut, onComplete: NormalizeRotation()});
					}else{
						NormalizeRotation();
						gsap.to(cylinder.rotation, 0.5, {y :  -1 * card.name + Math.PI * 2, ease: Expo.easeOut, onComplete: NormalizeRotation()});
					}
				}
			}

			function Unzoom (){
				NormalizeRotation();
				gsap.to(camera.position, 0.5, {z : radius * Math.sqrt(3) + Math.PI , ease: Expo.easeOut, onComplete: NormalizeRotation()});
				camera.fov = Math.atan( Math.tan( 60 * Math.PI / 360 ) / camera.aspect ) * 360 / Math.PI;
				camera.updateProjectionMatrix();
				zoom = false;
			}

			function Zoom(){
				NormalizeRotation();
				gsap.to(camera.position, 0.5, {z : radius + 6.53, ease: Expo.easeOut, onComplete: NormalizeRotation()});
				camera.fov = 30;
				camera.updateProjectionMatrix();
				zoom = true;
			}

			function NormalizeRotation(){
				if (Math.abs(cylinder.rotation.y) <= 0.01) cylinder.rotation.y = 0;
				if (Math.abs(Math.PI - Math.abs( Math.abs(-cylinder.rotation.y - (Math.PI *2)) - Math.PI)) < 0.01) cylinder.rotation.y = 0;
				while (cylinder.rotation.y < 0) cylinder.rotation.y = cylinder.rotation.y + Math.PI * 2;
				while (cylinder.rotation.y > Math.PI *2) cylinder.rotation.y = cylinder.rotation.y - Math.PI * 2;
				if (Math.abs(cylinder.rotation.y) <= 0.01) cylinder.rotation.y = 0;
				if (Math.abs(Math.PI - Math.abs( Math.abs(-cylinder.rotation.y - (Math.PI *2)) - Math.PI)) < 0.01) cylinder.rotation.y = 0;
				console.log("normalized");
			}
		</script>
	</body>
</html>