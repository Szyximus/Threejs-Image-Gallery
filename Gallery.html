<html>
	<head>
		<title>three.js WebGL Roulette Gallery</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/LightProbeGenerator.js"></script>
		<script src="js/gsap.min.js"></script>
		<script src="js/EasePack.min.js"></script>
		<script src="js/EaselPlugin.min.js"></script>
		<script src="js/threex.domevents.js"></script>
		<!--<script src="js/Draggable.js"></script>-->

		<script>
			

			var scene, camera, renderer, env, cylinder, lightProbe, photos, domEvents, selected;
			var gallery = [];
			

			
			Init();
			LoadPhotoList();
			
			//TEMPORARY CAMERA CONTROLS:
			let controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', renderer);
			
			render();

			function Init(){
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.01, 100 );
				renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement);

				domEvents = new THREEx.DomEvents(camera,renderer.domElement);

				window.addEventListener('resize', () => { //Handle Window Resize
					renderer.setSize( window.innerWidth, window.innerHeight);
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
				})

				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );
				// light

				directionalLight = new THREE.DirectionalLight( 0xffffff, THREE.directionalLightIntensity );
				directionalLight.position.set( 10, 10, 10 );
				scene.add( directionalLight );
								
				// envmap
				var genCubeUrls = function ( prefix, postfix ) {
		 		return [
		 			prefix + 'px' + postfix, prefix + 'nx' + postfix,
		 			prefix + 'py' + postfix, prefix + 'ny' + postfix,
					prefix + 'pz' + postfix, prefix + 'nz' + postfix
		 			];
			 	};
			 	var urls = genCubeUrls( 'textures/cube/pisa/', '.png' );
			 	new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {
					cubeTexture.encoding = THREE.sRGBEncoding;
			 		lightProbe.copy( THREE.LightProbeGenerator.fromCubeTexture( cubeTexture ) );
					env = cubeTexture;

				 } );
				 
			 	var geometry = new THREE.CylinderGeometry(3,3,2,64);
				var material = new THREE.MeshStandardMaterial( {
			 			color: 0xffffff,
			 			metalness: 0,
			 			roughness: 0.5,
			 			envMap: env,
			 			envMapIntensity: THREE.envMapIntensity * 100,
			 		} );
				cylinder = new THREE.Mesh( geometry, material );
				scene.add( cylinder);
			}

			function render() {
				requestAnimationFrame( render );



				//console.log(photos);

				renderer.render( scene, camera );
			};

			function LoadPhotoList(){

				var xmlhttp = new XMLHttpRequest();
				xmlhttp.onreadystatechange = function() {
 					if (this.readyState == 4 && this.status == 200) {
    				var myObj = JSON.parse(this.responseText);
    				photos = myObj;
  					}
				};
				xmlhttp.open("GET", "./photos.json", true);
				xmlhttp.send();

				var waitForLoad = timeoutms => new Promise((r, j)=>{
    				var check = () => {
					  console.warn('checking')
      				if(typeof photos !== 'undefined'){
						r();
						console.log(photos);
						PrepareGallery();
					  } 
      				else if((timeoutms -= 100) < 0)
        				j('timed out!')
      				else
        				setTimeout(check, 100)
    				}
   			 		setTimeout(check, 100)
  				})
		 	  	waitForLoad(2000);
			}
			function PrepareGallery(){

				for (var i = 0; i < photos.length; i++){
					var geometry = new THREE.PlaneGeometry(2.5,3.5);
					var texture = new THREE.TextureLoader().load('photos/'+ photos[i])
					texture.magFilter = THREE.NearestFilter;
					texture.minFilter = THREE.LinearMipmapNearestFilter;
					texture.anisotropy = 16;
					var material = new THREE.MeshPhysicalMaterial( {
						color: 0xffffff,
						map: texture
			 		} );
					var card = new THREE.Mesh( geometry, material );
					scene.add(card);
					gallery.push(card);
				}

				var radius = (3 * gallery.length) / (2 * Math.PI);

				camera.position.z = radius + 3;

				for (var i = 0; i < gallery.length; i++){
					
					var angle = (i / (gallery.length/2)) * Math.PI;
    				gallery[i].position.x = (radius * Math.cos(angle));
					gallery[i].position.z = (radius * Math.sin(angle));
					gallery[i].rotation.y = (Math.PI * 0.5) - angle;
					gallery[i].name = (JSON.stringify(i));
					domEvents.addEventListener(gallery[i], 'mouseover', event => HighlightCard(gallery[i]));
				}

			}
			function HighlightCard(card){
				console.log(card);
			}
		</script>
	</body>
</html>